# 6.17 周练小结

## A - 路径问题

一道偏简单的倍增题。首先一上来打暴力：

```c++
for (int s = 1; s <= n; s++)
{
    int cur = s;
    int ans = 0;
    for (int i = 1; i <= k; i++)
    {
        ans = max(ans, edges[cur].w);
        cur = edges[cur].t;
    }
    printf("%d\n", ans);
}
```

之后由跳点的过程很容易联想到倍增的思路，于是用 ST 表处理出从各个点跳 $2^i$ 步后的答案和停留位置。输出答案时把 $k$ 按二进制拆位处理即可。

```c++
const int MAXN = 500005;
const int MAX_LOG = 24;
struct Node
{
    int dest, ans;
};
int n, k;
Node edges[MAXN];
Node st[MAX_LOG][MAXN];

scanf("%d%d", &n, &k);
for (int i = 1; i <= n; i++)
    scanf("%d", &edges[i].dest);
for (int i = 1; i <= n; i++)
    scanf("%d", &edges[i].ans);

for (int i = 1; i <= n; i++)
{
    st[0][i].ans = edges[i].ans;
    st[0][i].dest = edges[i].dest;
}
for (int lg = 1; (1 << (lg - 1)) <= k; lg++)
{
    for (int i = 1; i <= n; i++)
    {
        st[lg][i].ans = max(st[lg - 1][i].ans, st[lg - 1][st[lg - 1][i].dest].ans);
        st[lg][i].dest = st[lg - 1][st[lg - 1][i].dest].dest;
    }
}

for (int i = 1; i <= n; i++)
{
    int ans = 0, step = k, lg = 0, cur = i;
    while (step > 0)
    {
        if (step & 1 == 1)
        {
            ans = max(ans, st[lg][cur].ans);
            cur = st[lg][cur].dest;
        }
        step = (step >> 1), lg++;
    }
    printf("%d\n", ans);
}
```

需要注意的几点：

- 多维数组尽量把小的一维靠前放，可以适应 CPU 的缓存机制从而节约时间。本题如果把两维交换会慢上 40% 左右，尽管对于 AC 没有问题，但一定要养成习惯，以防被毒瘤数据坑；
- ST 表的递推过程不要写错，要时刻明确各个下标和值的含义。感觉有点绕或者不太熟练可以纸笔推导或打成表验证。
- 交代码之前一定要对拍才有满分的自信！

## B - 互质

对于 $n \leq 10^{6}$ 的情况：可以直接用 `int` 存数，数出 $k$ 的数量（枚举 $1$ 到 $n$，判断 $gcd(i,n)$ 是否为 $1$），再输出第 $k/2$ 个满足条件的数。也可以用埃氏筛预处理出所有质数，因为对于一个质数 $p$ 一定有 $p-1$ 个数与它互质（比它小的所有正整数），答案即为 ${p-1} \over 2$。

```c++
// fmark[i]=true 表示i不是质数
fmark[1] = true;
for (int d = 2; d < MAXN; d++)
{
    if (fmark[d])
        continue;
    for (int f = 1; f * d < MAXN; f++)
    {
        fmark[d * f] = true;
    }
}

scanf("%d", &num);
if (fmark[num])
{
    for (int i = 1; i <= num; i++)
    {
        // dmark[i]=true 表示i与num互质
        dmark[i] = __gcd(i, num) == 1;
        if (dmark[i])
            k++;
    }
    int count = 0;
    for (int i = 1; i <= num; i++)
    {
        if (dmark[i])
            count++;
        if (count == (k + 1) / 2)
        {
            printf("%d\n", i);
            break;
        }
    }
}
else
{
    // 是质数就可以直接得出答案
    printf("%d\n", num >> 1);
}
```

这么做只能拿 $50$ 分，而且一看数据范围：$n \leq 10^{(10^6)}$！想必这道题一定不是硬算，而是答案与输入之间有某种规律。找规律的第一步当然是打表：

```
num=1 ans=1
num=2 ans=1
num=3 ans=1
num=4 ans=1
num=5 ans=2
num=6 ans=1
num=7 ans=3
num=8 ans=3
num=9 ans=4
num=10 ans=3
num=11 ans=5
num=12 ans=5
num=13 ans=6
...
```

这么看不怎么方便发现规律，可以把奇数和偶数分开：

```
// 奇数
num=1 ans=1
num=3 ans=1
num=5 ans=2
num=7 ans=3
num=9 ans=4
num=11 ans=5
num=13 ans=6
...

// 偶数
num=2 ans=1
num=4 ans=1
num=6 ans=1
num=8 ans=3
num=10 ans=3
num=12 ans=5
num=14 ans=5
...
```

果然，答案与输入之间存在非常明显的算数关系。至此就可以拿下 $n \leq 10^{18}$ 的 80 分了：

```c++
scanf("%lld", &num);
if (num <= 2)
    printf("1\n");
else if (num % 2 == 1)
    printf("%lld\n", (num - 1) / 2);
else
    printf("%lld\n", num / 2 - ((num % 4LL == 0) ? 1 : 2));
```

想要拿满分也不是很难，套个高精度就好了。

- **要有面向数据编程的思想。** 看到题目的数据范围要揣摩出题人的意图，如果数据大到离谱、需要用到高精度（比如本题），那么正解往往会用到某些“出人意料”的推论，而不是用标准的算法或数据结构硬算。
- **要勇于打表找规律。** 很多时候题目做不出来不是因为码力不行，而是想得太复杂，导致“不屑于”打表，但答案往往就蕴含在打表发现的规律中。~~除非有极强的数学功底可以严格证明出需要的结论~~

## C - 搬砖

- 对于所有的 $h$ 奇偶性相同的情况：一定可以砌出完整的墙，砖全都竖着放就行。答案为初始 $h$ 的最大值；
- 对于 $h$ 构成等差数列的情况：看公差是奇数还是偶数，如果是偶数那么结论同上，如果是奇数那一定砌不成完整的墙。

特殊情况考虑完后，如何得 $n \leq 10$ 的小数据分呢？第一思路是模拟：选出最低点的凹槽，砖尽量横放，如果凹槽只有一格宽就竖着放；一块一块放砖直到墙齐平，输出答案。

可惜的是，这样做一分都拿不到。为什么？因为 $h$ 之间可能相差极大，导致一块一块砖放置极其浪费时间，加上多组数据可以轻松地把模拟做法卡到一分不剩。因此需要对整个 $h$ 数组整体考虑。

> 正解思路 1：用链表+优先队列的方式储存 $h$ 数组，每次选出最低点。如果在最低点有相邻两块的平地，则可以在链表中直接消去这两个数；否则就放一块竖的砖块（值加上 $2$）。答案为链表中最后剩下的那个数。如果放砖的次数超过了某个阈值，就认为此种情况无解。
>
> 正解思路 2：用小脚趾思考以后不难发现，对于有解的情况，设 $h$ 的最大值为 $MX$，那么答案一定为 $MX,MX+1,MX+2$ 三者之一。对于每种答案依次判断是否可行即可。无解情况有这样一种性质：相邻的两列高度之差的绝对值全部都为奇数，根据这一点可以把无解情况提前判断掉。

- 不能拘泥于局部的模拟做法，尤其是发现模拟法和数据规模无关且极为费时时，要及时转换思路，从全局考虑问题。
- 特殊情况有时候可以为正解提供一点思路，但有时就只是拿来凑分数的而已。考试时有想过把一般情况的序列拆成若干个等差数列分别处理，但这种思路最终还是走不通。~~“没有无缘无故的第一小问”这句话在 OI 界不成立（~~
- 总之做题时一定要**格局打开** ，一种思路不行要赶紧换一种思路，局部不行就考虑整体，整体解不了就拆分成子问题。
