# 4.19 周练小结

## A - 小明摆三角形

本来是一道非常简单的枚举题，但题意并不是很明确木棍能不能重复使用，尝试了两次后也没有往这方面多想。

还有一点关于最优方案：尽可能让长度相差尽量小的木棍凑到一起就可以摆出最多的三角形，因此在枚举前需要 `sort` 一下。

```c++
// 节省篇幅，框架和“望词生意”的定义就不粘贴了

bool isTri(int a, int b, int c) // 单独定义函数避免单行if过于冗长
{

    return a + b > c && a + c > b && b + c > a;

}

for (int i = 0; i < n; i++)
{

    for (int j = i + 1; j < n; j++)
    {
        for (int k = j + 1; k < n; k++)
        {
            if (mark[i] || mark[j] || mark[k])  // mark用于木棍判重
                continue;
            if (isTri(sticks[i], sticks[j], sticks[k]))
            {
                ans++;
                mark[i] = true;
                mark[j] = true;
                mark[k] = true;
            }
        }
    }

}

```

## B - 佩奇与乔治玩游戏

这题需要将所有的策略与情况讨论清楚：

-   1 个点：显然除非点的坐标为 1，否则永远都是 Peppa 获胜；

-   2 个点：Peppa 可以将两个点直接靠在一起，即移动 $p_2$ 到 $p_1$ 的右边一格，之后无论 George 怎么移动 $p_1$，Peppa 都将 $p_2$ 移动到紧挨着 $p_1$ 的位置。因为两个点最终都要位于最左侧，因此这样可以保证 $p_1$ 靠到最左后下一轮 $p_2$ 也靠到最左，从而保证 Peppa 获胜。唯一的例外情况是两个点一开始就靠在一起，这样 Peppa 就失去了控制优势从而 George 获胜。
-   3 个点：首先尽量让 $p_1$ 靠向最左侧，再让 $p_3$ 靠近 $p_2$，这样就转化成了 2 个点的情况，此时轮到的即为败者。问题是如何判断优势在谁呢？如果 $p_1$ 到左端点的距离等于 $p_2$ 到 $p_3$ 的距离，那么无论 George 怎么移动棋子，Peppa 都一定可以达成上述目标从而获胜；反之 Peppa 需要浪费一回合从而 George 获胜。
-   4 个点及以上：将点两两分成 $n/2$ “堆”（若奇数个点则把 $1$ 号位看成一个无法移动的点），尽量把每一堆的点紧挨在一起，再转化为 3 个点的情况。容易发现，每处理完一个堆后，当前回合的玩家都会改变，因此还要考虑堆的个数。

将上述情况综合起来，可以推出，Peppa 获胜的充分必要条件是每一“堆”点间距离的“异或和”不为 $0$。

```c++
x = 0;  // 时刻记得有多组数据！
scanf("%d", &n);
for (int i = 1; i <= n; i++)
{
    scanf("%d", p + i);
}
sort(p + 1, p + n + 1);        // 输入的点坐标不一定有序，记得sort
for (int i = n; i > 0; i -= 2) // 两两点作为一堆
{
    x ^= (p[i] - p[i - 1] - 1); // 每一堆的距离求“异或和”（把所有数值用异或运算连接）
}
if (x == 0)
{
    printf("George will win\n");
}
else
{
    printf("Peppa will win\n");
}
```

## C - 比赛

可以直接枚举所有的对手，给能够推出胜负的打上标记并计数；也可以用类似于 Floyd 算法的思想，通过动态规划枚举一个中介点将所有对手的胜负情况推出，最后再计数。

```c++
int graph[MAXN][MAXN]; // 1赢，0输，-1未知，-2无解
int dp(int a, int b)
{

    if (graph[a][b] != -1)  // 记忆化搜索模板
        return graph[a][b];

    graph[a][b] = -2;   // 先假设无解

    for (int k = 1; k <= n; k++)    // 枚举中介点，很像 Floyd 找最短路径时利用中介点来松弛的思想
    {
        if (k == a || k == b)
            continue;
        if (dp(a, k) == 1 && dp(k, b) == 1) // 有效传递
        {
            graph[a][b] = 1;
            graph[b][a] = 0;
            return graph[a][b];
        }
    }
    return graph[a][b];

}

int main()
{

    ...
    for (a = 1; a <= n; a++)
    {
        for (b = 1; b <= n; b++)
        {
            if (a == b)
                continue;
            dp(a, b);
        }
    }

    int ans = 0;
    for (a = 1; a <= n; a++)    // 必须先DP处理一遍再计数，不能一边DP一边数
    {
        for (b = a + 1; b <= n; b++)
        {
            if (graph[a][b] == -2)
                ans++;
        }
    }
    printf("%d\n", ans);

}

```

## D - 桌球的艺术

模拟做法有点碰运气的成分，因为不知道循环该在什么时候退出（球若不能掉进角落则路径一定会存在环，但环的大小可能是个天文数字）。

> ~~模拟不如随机数来的分多 ——[ASteepMountain](https://www.luogu.com.cn/user/766639)~~

正解自然必须经过数学推导。想象复制无限张球桌并呈网格放置，由于球反弹时路径的对称性，可以把“折叠”在一张球桌上的路径“展开”成一条直线。球能掉进角落的充分必要条件是这条直线经过某个球桌的角落点，即过点 $(k_0n, k_1m) (k_0, k_1 \in \Z)$。于是可以求出这条直线的解析式并寻求一个 $k_0, k_1$ 的解即可。

差点忘了：$v_x$ 或 $v_y$ 为 $0$ 时需要特判！

```c++
// Insert Code Here
```
